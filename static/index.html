<html>
<head>
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript" src="js/g.js" charset="UTF-8"></script>
<script type="text/javascript" src="js/g.web.js" charset="UTF-8"></script>
<script type="text/javascript">

function on_load()
{
const asset_list = [
    'shaders/basic_textured.vert',
    'shaders/basic_textured.frag',
    'imgs/stars.jpg',
    'imgs/test.png',
    'imgs/player-0.png',
    'imgs/player-1.png',
    'meshes/plane.json',
    'meshes/exported-cube.json',
    'meshes/player-1.json',
    'meshes/player-0.json'
];

const k = {
    camera: {
        snap: 10
    },
    mouse: {
        sensitivity: 0.005
    }
};

var game = {
    cam: new g.web.gfx.camera(),
    t: 0,
    // player: {},
    my_id: 0,
    state: {}
};

game.cam.view([0, 0, 0], [0, 0, 0], [0, 1, 0]);
game.cam.position = [0, 0, 0];
game.cam.up = [0, 1, 0];
game.cam.q = [0, 0, 0, 1];

g.web.canvas(document.getElementsByTagName('canvas')[0]);

g.initialize(function ()
{
    g.is_running = false;


    g.web.assets.load(asset_list,
    function() {
        g.web.gfx.shader.create('basic_textured',
            g.web.assets['shaders/basic_textured.vert'],
            g.web.assets['shaders/basic_textured.frag']
        );

        g.web.assets['mesh/cube'] = g.web.gfx.mesh.create(g.web.assets['meshes/exported-cube.json']);
        g.web.assets['mesh/player-1'] = g.web.gfx.mesh.create(g.web.assets['meshes/player-1.json']);
        g.web.assets['mesh/player-0'] = g.web.gfx.mesh.create(g.web.assets['meshes/player-0.json']);

        g.web.assets['tex/stars'] = g.web.gfx.texture.repeating()
                                                     .pixelated()
                                                     .create(g.web.assets["imgs/stars.jpg"]);
        g.web.assets['tex/player-0'] = g.web.gfx.texture.repeating()
                                                     .pixelated()
                                                     .create(g.web.assets["imgs/player-0.png"]);                                                     

        g.web.assets['tex/player-1'] = g.web.gfx.texture.repeating()
                                                        .pixelated()
                                                        .create(g.web.assets["imgs/player-1.png"]);

        g.web.assets['tex/test'] = g.web.gfx.texture.repeating()
                                                     .pixelated()
                                                     .create(g.web.assets["imgs/test.png"]);
        g.is_running = true;

        // me = {
        //     mesh: g.web.assets['mesh/cube'],
        //     texture: g.web.assets['tex/test'],
        //     position: [0, 0, 0],
        //     thrust: [0, 0, 0],
        //     q: [0, 0, 0, 1]
        // };
    });

	return true;
});


g.web.pointer.on_move(function (event)
{
    var q = game.state.players[game.my_id].q || [0, 0, 0, 1];

    const dqx = [].quat_rotation([0, 1, 0], event.movementX * k.mouse.sensitivity);
    const dqy = [].quat_rotation([1, 0, 0], event.movementY * k.mouse.sensitivity);
    const dq = dqx.quat_mul(dqy)
    q = q.quat_mul(dq);

    g.web.socket().send({topic:'ori', q: q});
});


g.web.pointer.on_delta(function (event) { });


g.web.on_message(function (msg)
{
    switch(msg.topic)
    {
        case 'state':
            game.state = msg.state;
            game.my_id = msg.player_id;
            break;
    }
});


g.update(function (dt)
{
    // const forward = me.q.quat_rotate_vector([0, 0, 1]);
    // const up = game.player.q.quat_rotate_vector([0, 1, 0]);
    // const right = forward.cross(up);

    var thrust = [0, 0, 0];
	if (g.web.key.is_pressed('w')) { thrust = thrust.add([0, 0, 1]); }
    if (g.web.key.is_pressed('s')) { thrust = thrust.add([0, 0, -1]); }
    if (g.web.key.is_pressed('a')) { thrust = thrust.add([-1, 0, 0]); }
    if (g.web.key.is_pressed('d')) { thrust = thrust.add([1, 0, 0]); }
    if (g.web.key.is_pressed(' ')) { thrust = thrust.add([0,-1, 0]); }
    if (g.web.key.is_pressed('Shift')) { thrust = thrust.add([0, 1, 0]); }

    var me = game.state.players[game.my_id]
    if (g.web.key.is_pressed('q')) { me.q = me.q.quat_mul([].quat_rotation([0, 0, 1], dt)); }
    if (g.web.key.is_pressed('e')) { me.q = me.q.quat_mul([].quat_rotation([0, 0, 1], -dt)); }

    if (thrust.sub(me.thrust).len() > 0)
    {
        g.web.socket().send({topic:'ori', q: me.q});
        g.web.socket().send({topic:'thrust', thrust: thrust});
        me.thrust = thrust;
    }

    update_camera(game.cam, game.state.players[game.my_id], 8, dt);

    game.t += dt;
});

function update_camera(camera, player, dist, dt)
{
    const q = player.q;//.quat_inverse();
    const forward = q.quat_rotate_vector([0, 0, 1]);
    var up = q.quat_rotate_vector([0, 1, 0]);

    camera.position = camera.position.lerp(player.position.add(forward.mul(-dist)), dt * k.camera.snap);
    camera.up = camera.up.lerp(up, dt * k.camera.snap);


    camera.look_at(camera.position, player.position, camera.up);
}

function draw_skybox()
{
    var view = [].view([0,0,0], game.cam._forward, game.cam._up);

    gl.disable(gl.DEPTH_TEST);
    g.web.assets['mesh/cube'].using_shader('basic_textured')
                             .with_attribute({name:'a_position', buffer: 'positions', components: 3})
                             .with_attribute({name:'a_tex_coord', buffer: 'texture_coords', components: 2})
                             .set_uniform('u_proj').mat4(game.cam.projection())
                             .set_uniform('u_view').mat4(view)
                             .set_uniform('u_model').mat4([].I(4).mul(1100))
                             .set_uniform('u_texture').texture(g.web.assets['tex/stars'])
                             .draw_tris();
    gl.enable(gl.DEPTH_TEST);
}

function draw_player(player)
{
    // const model = [].translate(player.position).mat_mul(player.q.quat_inverse().quat_to_matrix());
    const model = player.q.quat_inverse().quat_to_matrix().mat_mul([].translate(player.position));
    const mesh = g.web.assets[player.mesh];

    mesh.using_shader('basic_textured')
        .with_attribute({name:'a_position', buffer: 'positions', components: 3})
        .with_attribute({name:'a_tex_coord', buffer: 'texture_coords', components: 2})
        .with_camera(game.cam)
        .set_uniform('u_model').mat4(model)
        .set_uniform('u_texture').texture(g.web.assets[player.texture])
        .draw_tris();
}

g.web.draw(function (dt)
{
    if (g.is_running == false) { return; }

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    game.cam.perspective(Math.PI / 3, 0.1, 1000);

    draw_skybox();

    for (const player_id in game.state.players)
    {
        draw_player(game.state.players[player_id]);
    }

    draw_player({
        mesh: 'mesh/player-1',
        texture: 'tex/player-1',
        position: [0, 0, 10],
        q: [0, 0, 0, 1]
    });
});

g.start();
}

</script>
</head>

<body style="margin:0" onload="on_load()">
<canvas style="padding:0;margin:0;width:100%;height:100%"></canvas>
</body>
</html>
